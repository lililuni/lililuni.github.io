[{"title":"Java并发（7）--并发容器 J.U.C：Java.util.concurrency","date":"2019-01-22T03:52:40.000Z","path":"2019/01/22/Java并发（7）--并发容器 J.U.C：Java.util.concurrency/","text":"Java并发容器JUC是三个单词的缩写。是JDK下面的一个包名。即Java.util.concurrency。上一节中，ArrayList、HashMap、HashSet对应的同步容器保证其线程安全，这节我们介绍一下其对应的并发容器 1. ArrayList –&gt; CopyOnWriteArrayList 以下部分内容引自CopyOnWriteArrayList CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。 源码分析：添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的。12345678910111213141516171819202122232425262728293031public boolean add(T e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; // 复制出新数组 Object[] newElements = Arrays.copyOf(elements, len + 1); // 把新元素添加到新数组里 newElements[len] = e; // 把原数组引用指向新数组 setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125;final void setArray(Object[] a) &#123; array = a;&#125; 2. HashMap –&gt; Hashtable–&gt; ConcurrentHashMap 以下部分内容引自Java多线程系列–“JUC集合”04之 ConcurrentHashMap HashMap, Hashtable, ConcurrentHashMap之间的关联如下 HashMap是非线程安全的哈希表，常用于单线程程序中。 Hashtable是线程安全的哈希表，它是通过synchronized来保证线程安全的；即，多线程通过同一个“对象的同步锁”来实现并发控制。Hashtable在线程竞争激烈时，效率比较低(此时建议使用ConcurrentHashMap)！因为当一个线程访问Hashtable的同步方法时，其它线程就访问Hashtable的同步方法时，可能会进入阻塞状态。 ConcurrentHashMap是线程安全的哈希表，它是通过“锁分段”来保证线程安全的。ConcurrentHashMap将哈希表分成许多片段(Segment)，每一个片段除了保存哈希表之外，本质上也是一个“可重入的互斥锁”(ReentrantLock)。多线程对同一个片段的访问，是互斥的；但是，对于不同片段的访问，却是可以同步进行的。 ConcurrentHashMap数据结构： 3. HashSet –&gt; CopyOnWriteArraySet 以下部分内容引自Java多线程系列–“JUC集合”03之 CopyOnWriteArraySet CopyOnWriteArraySet是线程安全的无序的集合，可以将它理解成线程安全的HashSet。有意思的是，CopyOnWriteArraySet和HashSet虽然都继承于共同的父类AbstractSet；但是，HashSet是通过“散列表(HashMap)”实现的，而CopyOnWriteArraySet则是通过“动态数组(CopyOnWriteArrayList)”实现的，并不是散列表。和CopyOnWriteArrayList类似，CopyOnWriteArraySet具有以下特性： 它最适合于具有以下特征的应用程序：Set 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。 它是线程安全的。 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。 迭代器支持hasNext(), next()等不可变操作，但不支持可变 remove()等 操作。 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。 4. TreeSet –&gt; ConcurrentSkipListSet 以下部分内容引自Java多线程系列–“JUC集合”06之 ConcurrentSkipListSet ConcurrentSkipListSet是线程安全的有序的集合，适用于高并发的场景。ConcurrentSkipListSet和TreeSet，它们虽然都是有序的集合。但是，第一，它们的线程安全机制不同，TreeSet是非线程安全的，而ConcurrentSkipListSet是线程安全的。第二，ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，而TreeSet是通过TreeMap实现的。 5. TreeMap –&gt; ConcurrentSkipListMap 以下部分内容引自Java多线程系列–“JUC集合”05之 ConcurrentSkipListMap ConcurrentSkipListMap是线程安全的有序的哈希表，适用于高并发的场景。ConcurrentSkipListMap和TreeMap，它们虽然都是有序的哈希表。但是，第一，它们的线程安全机制不同，TreeMap是非线程安全的，而ConcurrentSkipListMap是线程安全的。第二，ConcurrentSkipListMap是通过跳表实现的，而TreeMap是通过红黑树实现的。关于跳表(Skip List)，它是平衡树的一种替代的数据结构，但是和红黑树不相同的是，跳表对于树的平衡的实现是基于一种随机化的算法的，这样也就是说跳表的插入和删除的工作是比较简单的。 6. ConcurrentLinkedQueue 以下部分内容引自Java多线程系列–“JUC集合”10之 ConcurrentLinkedQueue ConcurrentLinkedQueue是线程安全的队列，它适用于“高并发”的场景。它是一个基于链接节点的无界线程安全队列，按照 FIFO（先进先出）原则对元素进行排序。队列元素中不可以放置null元素（内部实现的特殊节点除外）。 7. 安全共享对象策略 线程限制：一个被线程限制的对象，由线程独占，并且只能被占有它的线程修改 共享只读：一个共享只读的U帝乡，在没有额外同步的情况下，可以被多个线程并发访问，但是任何线程都不能修改它 线程安全对象：一个线程安全的对象或者容器，在内部通过同步机制来保障线程安全，多以其他线程无需额外的同步就可以通过公共接口随意访问他 被守护对象：被守护对象只能通过获取特定的锁来访问。 参考： CopyOnWriteArrayList Java多线程系列–“JUC集合”03之 CopyOnWriteArraySet Java多线程系列目录(共43篇)","tags":[{"name":"JUC","slug":"JUC","permalink":"http://yoursite.com/tags/JUC/"}]},{"title":"Hello World","date":"2019-01-22T02:04:20.269Z","path":"2019/01/22/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]